import 'dart:async';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'dart:math';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:path_provider/path_provider.dart';

part 'main.g.dart'; // This part will be generated by build_runner

// --- Data Model for a Match Result ---
@HiveType(typeId: 0)
class MatchResult extends HiveObject {
  @HiveField(0)
  final String teamAName;

  @HiveField(1)
  final String teamBName;

  @HiveField(2)
  final int teamAScore;

  @HiveField(3)
  final int teamBScore;

  @HiveField(4)
  final String winningTeam;

  @HiveField(5)
  final DateTime date;

  @HiveField(6)
  final int durationInSeconds;

  MatchResult({
    required this.teamAName,
    required this.teamBName,
    required this.teamAScore,
    required this.teamBScore,
    required this.winningTeam,
    required this.date,
    required this.durationInSeconds,
  });
}

// A constant for our Hive box name
const String kMatchHistoryBox = 'matchHistoryBox';

Future<void> main() async {
  // Ensure Flutter is initialized.
  WidgetsFlutterBinding.ensureInitialized();
  
  // Initialize Hive and open the box
  final appDocumentDir = await getApplicationDocumentsDirectory();
  await Hive.initFlutter(appDocumentDir.path);
  Hive.registerAdapter(MatchResultAdapter());
  await Hive.openBox<MatchResult>(kMatchHistoryBox);

  runApp(const PadelPointApp());
}

// --- App Theme and Configuration ---
const Color _darkBackground = Color(0xFF121212);
const Color _darkAccentColor = Color(0xFFDFFF00);
const Color _lightAccentColor = Color(0xFF007BFF); // New, high-contrast color for light mode
const Color _lightTextColor = Colors.white;
const Color _darkSurfaceColor = Color(0xFF1E1E1E);

// --- Helper function to format duration ---
String formatDuration(int totalSeconds) {
    final duration = Duration(seconds: totalSeconds);
    final minutes = duration.inMinutes.remainder(60).toString().padLeft(2, '0');
    final seconds = duration.inSeconds.remainder(60).toString().padLeft(2, '0');
    return '$minutes:$seconds';
}


class PadelPointApp extends StatefulWidget {
  const PadelPointApp({super.key});

  @override
  State<PadelPointApp> createState() => _PadelPointAppState();
}

class _PadelPointAppState extends State<PadelPointApp> {
  ThemeMode _themeMode = ThemeMode.dark;

  void _toggleTheme() {
    setState(() {
      _themeMode = _themeMode == ThemeMode.dark ? ThemeMode.light : ThemeMode.dark;
    });
  }

  @override
  void dispose() {
    Hive.close(); // Close all boxes
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Padel Point',
      debugShowCheckedModeBanner: false,
      themeMode: _themeMode,
      theme: ThemeData(
        scaffoldBackgroundColor: const Color(0xFFF5F5F5),
        brightness: Brightness.light,
        primaryColor: _lightAccentColor,
        cardColor: Colors.white,
        textTheme: GoogleFonts.interTextTheme(ThemeData.light().textTheme).apply(
          bodyColor: Colors.black87,
          displayColor: Colors.black87,
        ),
        appBarTheme: AppBarTheme(
          backgroundColor: const Color(0xFFF5F5F5),
          elevation: 0,
          centerTitle: true,
          iconTheme: const IconThemeData(color: Colors.black87),
          titleTextStyle: GoogleFonts.inter(
            fontSize: 20.0,
            fontWeight: FontWeight.bold,
            color: Colors.black87,
          ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: _lightAccentColor,
            foregroundColor: Colors.white,
            textStyle: const TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
            padding: const EdgeInsets.symmetric(vertical: 16),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(30),
            ),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: Colors.grey.shade200,
          labelStyle: const TextStyle(color: Colors.black54),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: _lightAccentColor, width: 2),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide(color: Colors.grey.shade300),
          ),
        ),
      ),
      darkTheme: ThemeData(
        scaffoldBackgroundColor: _darkBackground,
        brightness: Brightness.dark,
        primaryColor: _darkAccentColor,
        cardColor: _darkSurfaceColor,
        textTheme: GoogleFonts.interTextTheme(ThemeData.dark().textTheme).apply(
          bodyColor: _lightTextColor,
          displayColor: _lightTextColor,
        ),
        appBarTheme: const AppBarTheme(
          backgroundColor: _darkBackground,
          elevation: 0,
          centerTitle: true,
          titleTextStyle: TextStyle(
            fontSize: 20.0,
            fontWeight: FontWeight.bold,
          ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: _darkAccentColor,
            foregroundColor: Colors.black,
            textStyle: const TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
            padding: const EdgeInsets.symmetric(vertical: 16),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(30),
            ),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: _darkSurfaceColor,
          labelStyle: const TextStyle(color: Colors.white70),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: _darkAccentColor, width: 2),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide(color: _darkSurfaceColor.withOpacity(0.5)),
          ),
        ),
      ),
      home: MatchSetupScreen(onThemeChanged: _toggleTheme, currentTheme: _themeMode),
    );
  }
}

// --- SCREEN 1: Match Setup ---

class MatchSetupScreen extends StatefulWidget {
  final VoidCallback onThemeChanged;
  final ThemeMode currentTheme;
  const MatchSetupScreen({super.key, required this.onThemeChanged, required this.currentTheme});

  @override
  State<MatchSetupScreen> createState() => _MatchSetupScreenState();
}

class _MatchSetupScreenState extends State<MatchSetupScreen> {
  final _teamAController = TextEditingController(text: 'Team A');
  final _teamBController = TextEditingController(text: 'Team B');
  int _selectedBestOf = 3; // 3 or 5 for "Best of"

  @override
  void dispose() {
    _teamAController.dispose();
    _teamBController.dispose();
    super.dispose();
  }

  void _startMatch() {
    // Basic validation
    if (_teamAController.text.isEmpty || _teamBController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please enter names for both teams.'),
          backgroundColor: Colors.redAccent,
        ),
      );
      return;
    }
    
    // Calculate the number of games needed to win for a "best of" series
    final int gamesToWin = (_selectedBestOf / 2).floor() + 1;

    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => ScoreboardScreen(
          teamAName: _teamAController.text,
          teamBName: _teamBController.text,
          gamesToWin: gamesToWin,
          bestOf: _selectedBestOf, // Pass the original "best of" value for display
        ),
      ),
    );
  }

  void _viewHistory() {
      Navigator.of(context).push(
          MaterialPageRoute(
              builder: (context) => const MatchHistoryScreen(),
          ),
      );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          'Padel Match',
          style: GoogleFonts.inter(fontWeight: FontWeight.bold),
        ),
        actions: [
          IconButton(
            icon: Icon(
              widget.currentTheme == ThemeMode.dark ? Icons.light_mode_outlined : Icons.dark_mode_outlined,
            ),
            onPressed: widget.onThemeChanged,
            tooltip: 'Toggle Theme',
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // --- Padel Logo ---
              Icon(
                Icons.sports_tennis,
                size: 150,
                color: Theme.of(context).primaryColor.withOpacity(0.8),
              ),
              const SizedBox(height: 40),

              // --- Team Name Inputs ---
              _buildTeamNameField(_teamAController, 'Team A'),
              const SizedBox(height: 20),
              _buildTeamNameField(_teamBController, 'Team B'),
              const SizedBox(height: 40),

              // --- Match Format Selector ---
              Text(
                'Match Format',
                textAlign: TextAlign.center,
                style: GoogleFonts.inter(
                  fontSize: 16,
                  color: Theme.of(context).textTheme.bodySmall?.color?.withOpacity(0.7),
                ),
              ),
              const SizedBox(height: 12),
              _buildMatchFormatSelector(),
              const SizedBox(height: 60),

              // --- Action Buttons ---
              ElevatedButton(
                onPressed: _startMatch,
                child: const Text('Start Match'),
              ),
              const SizedBox(height: 20),
              TextButton(
                  onPressed: _viewHistory,
                  child: Text(
                      'View Match History',
                      style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 16),
                  )
              )
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTeamNameField(TextEditingController controller, String label) {
    return TextField(
      controller: controller,
      decoration: InputDecoration(
        labelText: label,
      ),
      textAlign: TextAlign.center,
      style: const TextStyle(fontSize: 18, fontWeight: FontWeight.w500),
    );
  }

  Widget _buildMatchFormatSelector() {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    return Container(
      decoration: BoxDecoration(
        color: isDark ? _darkSurfaceColor : Colors.grey.shade200,
        borderRadius: BorderRadius.circular(30),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          _buildFormatOption(3),
          _buildFormatOption(5),
        ],
      ),
    );
  }

  Widget _buildFormatOption(int format) {
    final isSelected = _selectedBestOf == format;
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final isLightModeSelected = !isDark && isSelected;

    return Expanded(
      child: GestureDetector(
        onTap: () {
          setState(() {
            _selectedBestOf = format;
          });
        },
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          padding: const EdgeInsets.symmetric(vertical: 12),
          decoration: BoxDecoration(
            color: isSelected ? Theme.of(context).primaryColor : Colors.transparent,
            borderRadius: BorderRadius.circular(30),
          ),
          child: Text(
            'Best of $format',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: isLightModeSelected ? Colors.white : (isSelected ? Colors.black : (isDark ? Colors.white : Colors.black)),
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }
}


// --- SCREEN 2: Scoreboard ---

// Enum to identify teams clearly
enum Team { teamA, teamB }

// A class to hold the state for the undo feature
class ScoreState {
  final int teamAGames;
  final int teamBGames;
  final String teamAPoints;
  final String teamBPoints;
  final Team servingTeam;
  final int secondsElapsed;

  ScoreState({
    required this.teamAGames,
    required this.teamBGames,
    required this.teamAPoints,
    required this.teamBPoints,
    required this.servingTeam,
    required this.secondsElapsed,
  });
}

class ScoreboardScreen extends StatefulWidget {
  final String teamAName;
  final String teamBName;
  final int gamesToWin;
  final int bestOf;

  const ScoreboardScreen({
    super.key,
    required this.teamAName,
    required this.teamBName,
    required this.gamesToWin,
    required this.bestOf,
  });

  @override
  State<ScoreboardScreen> createState() => _ScoreboardScreenState();
}

class _ScoreboardScreenState extends State<ScoreboardScreen> {
  // --- State Variables ---
  late int _teamAGames;
  late int _teamBGames;
  late String _teamAPoints;
  late String _teamBPoints;
  late Team _servingTeam;
  final List<ScoreState> _history = [];

  // --- Timer Variables ---
  Timer? _timer;
  int _secondsElapsed = 0;


  @override
  void initState() {
    super.initState();
    _resetMatchState();
  }
  
  @override
  void dispose() {
    _timer?.cancel();
    super.dispose();
  }

  void _startTimer() {
    _timer?.cancel(); // Cancel any existing timer
    _timer = Timer.periodic(const Duration(seconds: 1), (_) {
      if (mounted) {
        setState(() {
          _secondsElapsed++;
        });
      }
    });
  }

  void _resetMatchState() {
    setState(() {
      _teamAGames = 0;
      _teamBGames = 0;
      _teamAPoints = '0';
      _teamBPoints = '0';
      _servingTeam = Random().nextBool() ? Team.teamA : Team.teamB;
      _history.clear();
      _secondsElapsed = 0;
      _startTimer();
      _saveState(); // Save initial state
    });
  }
  
  // --- Core Logic Methods ---

  void _saveState() {
    _history.add(ScoreState(
      teamAGames: _teamAGames,
      teamBGames: _teamBGames,
      teamAPoints: _teamAPoints,
      teamBPoints: _teamBPoints,
      servingTeam: _servingTeam,
      secondsElapsed: _secondsElapsed,
    ));
  }

  void _undoLastPoint() {
    if (_history.length > 1) {
      setState(() {
        _history.removeLast(); // Remove current state
        final lastState = _history.last; // Get previous state
        _teamAGames = lastState.teamAGames;
        _teamBGames = lastState.teamBGames;
        _teamAPoints = lastState.teamAPoints;
        _teamBPoints = lastState.teamBPoints;
        _servingTeam = lastState.servingTeam;
        _secondsElapsed = lastState.secondsElapsed;
      });
    } else {
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Cannot undo further.'))
        );
    }
  }

  void _addPoint(Team team) {
    _saveState();

    String currentPointsWinner = (team == Team.teamA) ? _teamAPoints : _teamBPoints;
    String currentPointsLoser = (team == Team.teamA) ? _teamBPoints : _teamAPoints;

    String newPointsWinner = '0';

    if (currentPointsWinner == '0') {
      newPointsWinner = '15';
    } else if (currentPointsWinner == '15') {
      newPointsWinner = '30';
    } else if (currentPointsWinner == '30') {
      newPointsWinner = '40';
    } else if (currentPointsWinner == '40') {
      if (currentPointsLoser == '40') {
        newPointsWinner = 'AD'; // Advantage
      } else if (currentPointsLoser == 'AD') {
        // This case handles when the player with AD loses the point. Score goes back to Deuce.
        _updatePoints('40', '40'); 
        return;
      } else {
        // Game win
        _addGame(team);
        return;
      }
    } else if (currentPointsWinner == 'AD') {
      // Game win from Advantage
      _addGame(team);
      return;
    }

    if (team == Team.teamA) {
      _updatePoints(newPointsWinner, _teamBPoints);
    } else { // Team B scored
      _updatePoints(_teamAPoints, newPointsWinner);
    }
  }
  
  void _updatePoints(String pointsA, String pointsB) {
      setState(() {
          _teamAPoints = pointsA;
          _teamBPoints = pointsB;
      });
  }

  void _addGame(Team team) {
    if (team == Team.teamA) {
      _teamAGames++;
    } else {
      _teamBGames++;
    }

    // Check for a match win
    if (_teamAGames == widget.gamesToWin) {
      _showMatchEndDialog(widget.teamAName);
      return; // Match is over
    } else if (_teamBGames == widget.gamesToWin) {
      _showMatchEndDialog(widget.teamBName);
      return; // Match is over
    }

    // If no match win, reset points and switch server
    setState(() {
      _teamAPoints = '0';
      _teamBPoints = '0';
      _servingTeam = (_servingTeam == Team.teamA) ? Team.teamB : Team.teamA;
    });
  }

  // --- Dialogs ---

  Future<void> _showMatchEndDialog(String winningTeam) async {
    _timer?.cancel(); // Stop the timer
    
    // Create the match result object
    final matchResult = MatchResult(
        teamAName: widget.teamAName,
        teamBName: widget.teamBName,
        teamAScore: _teamAGames,
        teamBScore: _teamBGames,
        winningTeam: winningTeam,
        date: DateTime.now(),
        durationInSeconds: _secondsElapsed,
    );
    
    // Add the result to the Hive box
    await Hive.box<MatchResult>(kMatchHistoryBox).add(matchResult);

    return showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return AlertDialog(
          backgroundColor: Theme.of(context).cardColor,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          title: Text(
            '$winningTeam Wins!',
            textAlign: TextAlign.center,
            style: GoogleFonts.inter(
              fontWeight: FontWeight.bold,
              color: Theme.of(context).primaryColor,
            ),
          ),
          content: Text(
            'Final Score: $_teamAGames - $_teamBGames',
            textAlign: TextAlign.center,
            style: const TextStyle(fontSize: 18),
          ),
          actionsAlignment: MainAxisAlignment.center,
          actions: <Widget>[
            TextButton(
              child: const Text('Close', style: TextStyle(color: Colors.grey)),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            ElevatedButton(
              child: const Text('New Match'),
              onPressed: () {
                Navigator.of(context).popUntil((route) => route.isFirst);
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _showResetConfirmationDialog() async {
    return showDialog<void>(
        context: context,
        builder: (BuildContext context) {
            return AlertDialog(
                backgroundColor: Theme.of(context).cardColor,
                title: const Text('Reset Match?'),
                content: const Text('Are you sure you want to reset the current match score?'),
                actions: [
                    TextButton(
                        child: const Text('Cancel', style: TextStyle(color: Colors.grey)),
                        onPressed: () => Navigator.of(context).pop(),
                    ),
                    TextButton(
                        child: const Text('Reset', style: TextStyle(color: Colors.redAccent)),
                        onPressed: () {
                            Navigator.of(context).pop();
                            _resetMatchState();
                        },
                    ),
                ],
            );
        }
    );
  }


  // --- Build Method ---
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 20.0),
          child: Column(
            children: [
              // Top header with timer
              _buildHeaderBar(),
              const SizedBox(height: 24),

              // Main Scoreboard Area
              Expanded(
                child: Row(
                  children: [
                    _buildTeamScoreCard(Team.teamA),
                    const SizedBox(width: 12),
                    _buildTeamScoreCard(Team.teamB),
                  ],
                ),
              ),
              const SizedBox(height: 24),

              // Info Bar
              Container(
                padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 24),
                decoration: BoxDecoration(
                  color: Theme.of(context).cardColor,
                  borderRadius: BorderRadius.circular(30),
                ),
                child: Text(
                  'First Serve • Best of ${widget.bestOf} Games',
                  style: GoogleFonts.inter(fontSize: 16, fontWeight: FontWeight.w500),
                ),
              ),
              const SizedBox(height: 20),

              // Bottom Action Bar
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  _buildTextButton('Undo', _undoLastPoint),
                  _buildTextButton('Reset', _showResetConfirmationDialog),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildHeaderBar() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(30),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          // Left side: Icon and Team Names
          Flexible(
            child: Row(
              children: [
                Icon(Icons.sports_tennis_rounded, color: Theme.of(context).primaryColor, size: 24),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    '${widget.teamAName} vs ${widget.teamBName}',
                    style: GoogleFonts.inter(fontSize: 16, fontWeight: FontWeight.bold),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ),
          // Right side: Timer
          Row(
            children: [
              Icon(Icons.timer_outlined, color: Theme.of(context).textTheme.bodySmall?.color?.withOpacity(0.7), size: 20),
              const SizedBox(width: 8),
              Text(
                formatDuration(_secondsElapsed),
                style: GoogleFonts.inter(
                  fontSize: 18,
                  fontWeight: FontWeight.w500,
                  fontFeatures: const [FontFeature.tabularFigures()],
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTextButton(String label, VoidCallback onPressed) {
    return TextButton(
        onPressed: onPressed,
        style: TextButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
            backgroundColor: Theme.of(context).cardColor,
        ),
        child: Text(
            label,
            style: TextStyle(color: Theme.of(context).textTheme.bodySmall?.color?.withOpacity(0.7), fontSize: 16),
        ),
    );
  }

  Widget _buildTeamScoreCard(Team team) {
    final teamName = (team == Team.teamA) ? widget.teamAName : widget.teamBName;
    final games = (team == Team.teamA) ? _teamAGames : _teamBGames;
    final points = (team == Team.teamA) ? _teamAPoints : _teamBPoints;
    final isServing = _servingTeam == team;

    return Expanded(
      child: GestureDetector(
        onTap: () => _addPoint(team),
        behavior: HitTestBehavior.opaque,
        child: Container(
          padding: const EdgeInsets.fromLTRB(10, 24, 10, 16),
          decoration: BoxDecoration(
            color: Theme.of(context).cardColor,
            borderRadius: BorderRadius.circular(24),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              // Team Name and Server Icon
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Flexible(
                    child: Text(
                      teamName,
                      style: GoogleFonts.inter(
                        fontSize: 22,
                        fontWeight: FontWeight.w600,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  const SizedBox(width: 8),
                  if (isServing)
                    Container(
                        width: 10, height: 10,
                        decoration: BoxDecoration(shape: BoxShape.circle, color: Theme.of(context).primaryColor)
                    ),
                ],
              ),
              // Score Column
              Expanded(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // Games
                    Text(
                      '$games',
                      style: GoogleFonts.inter(
                        fontSize: 100,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    // Points
                    Text(
                      points,
                      style: GoogleFonts.inter(
                        fontSize: 60,
                        fontWeight: FontWeight.w600,
                        color: points == 'AD'
                            ? Theme.of(context).primaryColor
                            : Theme.of(context).textTheme.bodyMedium?.color?.withOpacity(0.8),
                      ),
                    ),
                  ],
                ),
              ),
              // "Tap to add point" text
              Text(
                "Tap anywhere to add a point",
                style: GoogleFonts.inter(
                    fontSize: 12,
                    color: Theme.of(context).textTheme.bodySmall?.color?.withOpacity(0.5),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// --- SCREEN 3: Match History ---

class MatchHistoryScreen extends StatelessWidget {
    const MatchHistoryScreen({super.key});

    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text(
                    'Match History',
                    style: GoogleFonts.inter(fontWeight: FontWeight.bold),
                ),
            ),
            body: ValueListenableBuilder<Box<MatchResult>>(
                valueListenable: Hive.box<MatchResult>(kMatchHistoryBox).listenable(),
                builder: (context, box, _) {
                    final matches = box.values.toList().cast<MatchResult>();
                    if (matches.isEmpty) {
                        return Center(
                            child: Text(
                                'No saved matches yet.',
                                style: GoogleFonts.inter(color: Theme.of(context).textTheme.bodySmall?.color?.withOpacity(0.7), fontSize: 16),
                            ),
                        );
                    }

                    return ListView.builder(
                        padding: const EdgeInsets.all(16.0),
                        itemCount: matches.length,
                        itemBuilder: (context, index) {
                            // Display the list in reverse chronological order
                            final match = matches[matches.length - 1 - index];
                            final isTeamAWinner = match.winningTeam == match.teamAName;
                            final dateString = '${match.date.day}/${match.date.month}/${match.date.year}';
                            final textColor = Theme.of(context).textTheme.bodyMedium?.color;

                            return Card(
                                color: Theme.of(context).cardColor,
                                margin: const EdgeInsets.only(bottom: 16),
                                shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(16),
                                ),
                                child: Padding(
                                    padding: const EdgeInsets.all(20.0),
                                    child: Column(
                                        crossAxisAlignment: CrossAxisAlignment.start,
                                        children: [
                                            // Teams Row
                                            FittedBox(
                                              fit: BoxFit.scaleDown,
                                              child: Row(
                                                  mainAxisAlignment: MainAxisAlignment.center,
                                                  children: [
                                                      Text(
                                                          match.teamAName,
                                                          style: TextStyle(
                                                              fontSize: 20,
                                                              fontWeight: isTeamAWinner ? FontWeight.bold : FontWeight.normal,
                                                              color: isTeamAWinner ? Theme.of(context).primaryColor : textColor,
                                                          ),
                                                      ),
                                                      Padding(
                                                          padding: const EdgeInsets.symmetric(horizontal: 12.0),
                                                          child: Text(
                                                              'vs',
                                                              style: GoogleFonts.inter(fontSize: 16, color: textColor?.withOpacity(0.7)),
                                                          ),
                                                      ),
                                                      Text(
                                                          match.teamBName,
                                                          style: TextStyle(
                                                              fontSize: 20,
                                                              fontWeight: !isTeamAWinner ? FontWeight.bold : FontWeight.normal,
                                                              color: !isTeamAWinner ? Theme.of(context).primaryColor : textColor,
                                                          ),
                                                      ),
                                                  ],
                                              ),
                                            ),
                                            const SizedBox(height: 16),
                                            
                                            // Score
                                            Center(
                                                child: Text(
                                                    '${match.teamAScore} - ${match.teamBScore}',
                                                    style: GoogleFonts.inter(
                                                        fontSize: 32,
                                                        fontWeight: FontWeight.bold,
                                                    ),
                                                ),
                                            ),
                                            
                                            const SizedBox(height: 12),
                                            
                                            // Date and Duration
                                            Row(
                                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                              children: [
                                                Text(
                                                  'Duration: ${formatDuration(match.durationInSeconds)}',
                                                  style: TextStyle(
                                                    fontSize: 14,
                                                    color: textColor?.withOpacity(0.5),
                                                  ),
                                                ),
                                                Text(
                                                    dateString,
                                                    style: TextStyle(
                                                        fontSize: 14,
                                                        color: textColor?.withOpacity(0.5),
                                                    ),
                                                ),
                                              ],
                                            ),
                                        ],
                                    ),
                                ),
                            );
                        },
                    );
                },
            ),
        );
    }
}

